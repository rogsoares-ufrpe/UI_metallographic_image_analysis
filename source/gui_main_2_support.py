#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 18, 2023 04:33:30 PM -03  platform: Windows NT

# -*- coding: utf-8 -*-
"""
UNIVERSIDADE FEDERAL RURAL DE PERNAMBUCO - UFRPE
UNIDADE ACADÊMICA DO CABO DE SANTO AGOSTINHO - UACSA

@author(s):
    Rogério Soares (rogerio.soaress@ufrpe.br)
    
Created on Sun Apr 19 12:14:33 2020
"""

import inspect
import os
import xlsxwriter

# Image/plot modules
import matplotlib.pyplot as plt
from PIL import Image,ImageTk

# TKinter modules
import tkinter as tk
from tkinter.messagebox import showerror, showwarning, showinfo
from tkinter import filedialog

# from tabulate import tabulate
from prettytable import PrettyTable

# project modules
import gui_main_2
import canvas_manager as canvasmanager
import media
import ScaleWinDialog as swd
import cv2

import sys
sys.path.append('procedures')


_debug = True # False to eliminate debug printing from callback functions.

def main(*args):
    '''Main entry point for the application.'''
    
    global gsp_old
    gsp_old = 0
    
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, MainWindow
    _top1 = root
    MainWindow = gui_main_2.Toplevel_MainWindow(_top1)
    MainWindow.top.geometry("1290x690")
    
    global image_analyzer
    image_analyzer = media.MEDIA()    # object for Metallographic Image Analysis class
    
    global cmanager
    cmanager = canvasmanager.CanvasManager(MainWindow.MainCanvas)
    root.mainloop()
    
        
def open_segmentation_panel():
    """Open segmentation window settings"""
    global child
    child_root_segmentation = tk.Toplevel(root)
    child = gui_main_2.TopLevel_SegmentationWindow(child_root_segmentation)
    child_root_segmentation.attributes('-topmost',True)
    
    child.edge_detection_var.set("Canny")
    child.meanSTD_var.set("1")
    child.rb_filter.set(1)
    child.drawcnt_var.set(1)     
    

def open_procedure_panel():
    """Open the ASTM procedures window"""

    # if not image_analyzer.is_image_segmented():
    #     showwarning("Warning","Procedures can not be applied until grains segmentation has been performed.")
    #     return 
    
    global child_procedure
    child_root_procedure = tk.Toplevel(root)
    child_procedure = gui_main_2.TopLevel_MeasuringProcedure(child_root_procedure)
    child_root_procedure.attributes('-topmost',True)
    
    
    child_procedure.LineLength.insert(0, "400")
    child_procedure.NumLinesHeyns.insert(0,"1")
    child_procedure.CircunferenceJeffriesArea.insert(0,"5000")
    child_procedure.RB_procedure.set(1)
    child_procedure.HilliardCircunferenceDiameterEntry.insert(0,"400")
    # child_procedure.AbramsNumberInterceptsEntry.insert(0,"500")
    

import Jeffries, Heyns, Hilliard, Abrams
import procedures_support as ps

def apply_procedure_button():
    # procedures.apply(MainWindow, root, child_procedure, cmanager, image_analyzer) 
    """Apply ASTM procedure choose by user"""
    
    print("Apply ASTM procedure choose by user")
    
    var = int(child_procedure.RB_procedure.get())
    procedures = ["None", "Jeffries", "Heyns", "Hilliard", "Abrams"]
    print("Procedure: ", procedures[var])
    
    canvas = MainWindow.MainCanvas    
    image_analyzer.image_cv = None
    image_analyzer.image_cv = image_analyzer.image_original.copy()
    
    grains_contours = []
    
    if procedures[var] == "Jeffries":
       grains_contours = Jeffries.procedure(image_analyzer, cmanager, canvas, ps)
       
    elif procedures[var] == "Heyns":
        grains_contours = Heyns.procedure(image_analyzer, child_procedure, cmanager, canvas, ps)
        
    elif procedures[var] == "Hilliard":
        grains_contours = Hilliard.procedure(MainWindow, child_procedure, image_analyzer, cmanager, ps)
    
    elif procedures[var] == "Abrams":
        grains_contours = Abrams.procedure(image_analyzer, cmanager, canvas, ps)
    
    draw_bbox = False
    number_grains = False   
    
    if child_procedure.boundbox_var.get()==1:
        draw_bbox = True
        
    if child_procedure.numbergrains_var.get()==1:
        number_grains = True
        
    if draw_bbox:
        for cnt in grains_contours:
            x, y, w, h = cv2.boundingRect(cnt)
            canvas.create_rectangle((x+55,y+55),(x+w+55,y+h+55), outline="yellow", width=1)
            
    if number_grains:
        for counter, cnt in enumerate(grains_contours):
            counter += 1
            x, y, w, h = cv2.boundingRect(cnt)
            canvas.create_text((int(x+w/2)+55, int(y+h/2)+55), text=str(counter+1))
            



def print_message_on_TextBoard(msg):
    MainWindow.TextBox_output.insert('end',msg+'\n', ("centered"))
    MainWindow.TextBox_output.tag_configure("centered", justify='center')


def createPrettyTable():
    """
    Creates a table structure to be displayed as a PrettyTable. 
    It can be exported as well 
    """
    title, header, rows_analysis = image_analyzer.get_report_analysis()            
    rows_imgprop =                 image_analyzer.image_prop.get_report_analysis()            
    rows = rows_analysis + rows_imgprop 
    
    table = PrettyTable()
    table.title = title
    table.field_names = header
    table.add_rows(rows)
    table.align = "l"
    return table


def print_table_on_TextBoard(table):    
    MainWindow.TextBox_output.insert(tk.END, table)
    MainWindow.TextBox_output.insert('end','\n\n')
    
    
def apply_image_filter(the_filter):
    """Applies image filter selected on TopLevel_SegmentationWindow"""
    image_analyzer.set_image_filter(the_filter)
    image_analyzer.apply_filter_smooth_algorithms()
    
    fimg = image_analyzer.get_filtered_image()
    cimg = image_analyzer.set_image_for_canvas(fimg)    
    cmanager.display_image_on_canvas(cimg)


def select_filter():
    """Select image filter from VScale widget and then apply it to image.
    The filter can only be applied to a loaded image, otherwise warn user. """
    
    filter_name = ['None',
                   'Gaussian blur',
                   '2D convolution',
                   'Bilateral Filter',
                   'Median Blurring',
                   'Averaging',
                   'Laplacian']  
    
    i = int(child.rb_filter.get())
    
    print('filter name: ' + filter_name[i-1])
    
    if image_analyzer.is_image_loaded():
        apply_image_filter(filter_name[i-1])
    elif not(filter_name[i-1] == 'None'):
        print_message_on_TextBoard('Warning! Image file not loaded.')  
        

def start_grains_segmentation():
    """Defines if the user wants to detect grain/porous structure or phases through
    the group of radio buttons. The action is performed pressing <detect structure>
    button."""
    
    if not image_analyzer.is_image_loaded():
        msg=[1,"No file has been openned!"]
        CHKMSG(msg)
    else:
    
        # Edge detection Procedure
        edp = child.edge_detection_var.get()
        
        # Control grains size area display
        gsp = int(child.meanSTD_var.get())
    
        
        # Canny
        if edp=="Canny":
            """Performe image segmentation finding grains' constours and updating canvas.
               Returns an error if image was not loaded.
            """
    
            if not image_analyzer.img_loaded:
                showerror('Grains segmentation','Image file has not been opened.')
            else:
                
                msg=image_analyzer.find_grains(gsp)
                CHKMSG(msg)                
                
                #Convert grains areas in pixels to micrometers
                image_analyzer.convert_grains_pixel2micro()
               
                # after analysis, display report on text box                
                table = createPrettyTable()
                print_table_on_TextBoard(table)                
            
                # setup canvas for image display
                setup_canvas()
                
                display_options()
                
                # set loaded image to be displayed on canvas
                cimg = image_analyzer.set_image_for_canvas(image_analyzer.image_cv)
                
                # cimg = image_analyzer.get_image_for_canvas()
                cmanager.display_image_on_canvas(cimg)
                
                image_analyzer.save_analysis_image_files("sample")
                
                plot()
            
                
        else:
            showerror('Error','Phases detection not implemented yet.')       


def display_options():
    """
    Manager how grains should be displayed. Options read from checkboxes
    """
    if child.colorfill_var.get()==1:
        image_analyzer.fill_contours()
    
    if child.drawcnt_var.get()==1:
        image_analyzer.draw_contours()
        
    if child.boundarybox_var.get()==1:
        image_analyzer.draw_bounding_box()
        
    if child.numberedgrains_var.get()==1:
        image_analyzer.numbering_grains()
        
    if child.minmax_var.get()==1:
        image_analyzer.draw_minmax_grains_area()


def close_application(): 
    msg_box = tk.messagebox.askquestion('Exit Application', 
                                        'Are you sure you want to exit the application?',
                                        icon='warning')
    if msg_box == 'yes':
        root.destroy()

        
def open_image_file():
    
    filetypes = (
        ('Image file', '*.png *.jpg *jpeg'),
        ('HDF5', '*.hdf5'),
        ('All files', '*.*')
    )
    
    filename = filedialog.askopenfilename(
        title='Open a file',
        initialdir='/Users/roger/OneDrive/UFRPE/PESQUISA/Projeto - Analise de imagens metalograficas/Git/gui/UI_metallographic_image_analysis/images',
        filetypes=filetypes)

    if filename == '':        
        showinfo(title='Selected File',  
                 message="No image file opened.")
    else:
        
        # load image file: it just creates a cv2 object
        image_analyzer.load_image(filename)
        
        # setup canvas for image display
        setup_canvas()
        
        # Display directory path and file name on MainWindow
        MainWindow.LabelDirectoryPathName.configure(text=filename)
        
        
def setup_canvas():
    
    if not image_analyzer.is_image_loaded():
        showerror("Error","Image not loaded! ")
    else:
        
        # remove all previous graphics from previous image analysis
        cmanager.cleanup()
        
        # set loaded image to be displayed on canvas
        oimg = image_analyzer.get_image_original()
        
        # set loaded image to be displayed on canvas
        cimg = image_analyzer.set_image_for_canvas(oimg)
        
        # cimg = image_analyzer.get_image_for_canvas()
        cmanager.display_image_on_canvas(cimg)
        
        # set x-y scales on canvas 
        width, height = image_analyzer.get_image_dimensions() 
        cmanager.draw_xy_axis(width, height, image_analyzer.image_prop)
        

def open_data_image_window():
    """It just opens the Data Image Window and start event"""

    if not image_analyzer.is_image_loaded():
        showerror("Error", "Image not loaded!")
    else:
        global child_dataimage, child_root
        child_root = tk.Toplevel(root)
        child_dataimage = gui_main_2.ImageDataWindow(child_root)
        child_root.attributes('-topmost',True)
        
        global scale_win
        scale_win = swd.SWD(root, MainWindow.MainCanvas)
        root.bind("<Motion>", lambda e: scale_win.callback_movement(e))
        root.bind("<Button-1>", lambda e: scale_win.callback_click(e)) 
    
    
def conclude_data_image_collect():
    print("conclude_data_image_collect():")
    """
    Set image parameters (magnification and scale).
    Update image scale rulers (x-y): pixels to micrometers
    Closes window
    """   

    # if child_dataimage.EntryMagnification.get() == "":
    #     showwarning('Warning:','Image magnification unknow.')
    #     return 1
    
    # if child_dataimage.EntryScale.get() == "":
    #     showwarning('Warning:','Scale value unknow.')
    #     return 1
    
    # From scale window, get: 
    # 1. image magnification      (Entry box widget), 
    # 2. scale length             (pixels: from the red ruler plotted over drawing)
    # 3. scale taken from picture (micrometers: Entry box widget)
    M = 100 #float(child_dataimage.EntryMagnification.get())    
    scale_micrometers = 100 #float(child_dataimage.EntryScale.get())
    
    image_analyzer.image_prop.Magnification = M
    image_analyzer.image_prop.scale_micrometers = scale_micrometers
    
    
    info = 'Magnification: ' + str(M) + '\n Scale (um):' + str(scale_micrometers)
    # showinfo("Data image info", info)
    
    scale_pixels = 60 #scale_win.get()    
    info = 'scale_pixels = ' + str(scale_pixels)
    # showinfo("Data image info: ", info)
    
    width, height = image_analyzer.get_image_dimensions()
    image_analyzer.image_prop.convertion_scale_settings(scale_micrometers, 
                                                        scale_pixels, 
                                                        M, 
                                                        width, 
                                                        height)
    
    # apague a marcação da régua usada para capturar a escala da imagem e
    # redesenhe os valores das escalas vertical e horizontal (pixel -> um)
    setup_canvas()

    # close data image window    
    child_root.destroy()
    
       
def plot():  
    """
    Plots on canvas the histogram of grains areas
    """

    x = image_analyzer.grains_area    
    num_bins = 42    
    fig, ax = plt.subplots(figsize=(6.9, 4.6))
    
    # the histogram of the data
    n, bins, patches = ax.hist(x, num_bins, density=True)
    
    ax.set_xlabel('Value')
    ax.set_ylabel('Probability density')
    ax.set_title('Histogram of grains areas')   
    plt.savefig("hist.png", bbox_inches='tight')    
    
    one = ImageTk.PhotoImage(Image.open("hist.png"))
    root.one = one
    MainWindow.CanvasHistogram.create_image(0,0,image=one, anchor=tk.NW)   
  

def exporttoxlxs():
    """
    Description:
        
        Export the last data analysis to a .xlxs file.
    """   
    filename = filedialog.asksaveasfilename(initialfile = 'Untitled.xlsx',
                                            defaultextension=".xlsx",
                                            filetypes=[("Excel file","*.xlsx")])
    
    print('filename = ', filename)
    print('filename type = ', type(filename) )
    
    # get data to be written to file
    title, header, data_rows = image_analyzer.get_report_analysis()
    
    # Create a workbook and add a worksheet.
    workbook = xlsxwriter.Workbook(filename)
    worksheet = workbook.add_worksheet()
    
    # Start from the first cell. Rows and columns are zero indexed.
    row = 1
    col = 1
    
    # # print title
    # print('TITLE = ', title)
    worksheet.write(row, col, title)
    
    # # print headers
    row += 2
    worksheet.write(row, col, str(header[0]))
    worksheet.write(row, col+1, str(header[1]))
    
    # Iterate over the data and write it out row by row.
    row += 1
    for r in data_rows:
        worksheet.write(row, col,     r[0])
        worksheet.write(row, col + 1, r[1])
        row += 1
    
    workbook.close()
    
def about():
    showinfo('About MEDIA:',
                    'The Metallographic Digital Image Analyzer:\n\n'
                    'Institution: UFRPE - UACSA\n'
                    'Author: Prof. Rogério Soares da Silva\n'
                    'e-mail: rogerio.soaress@ufrpe.br\n'
                    'Year  : 2023')
    
    
def getLineInfo():
    print("\nInspection")
    print("---------------------------------------------------------------------")
    print("File     : " + os.path.basename(inspect.stack()[1][1])  + 
          "\nLine     : " + str(inspect.stack()[1][2])+
          "\nFunction : " + inspect.stack()[1][3])
    print("---------------------------------------------------------------------\n\n")
    
def CHKMSG(msg):
    if len(msg):
       if msg[0]==1:
           showwarning("Warning",msg[1])
       elif msg[0]==-1:
           showerror("Fatal error",msg[1])
           root.destroy()
    
if __name__ == '__main__':
    gui_main_2.start_up()

