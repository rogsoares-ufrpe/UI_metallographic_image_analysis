#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 7.6
#  in conjunction with Tcl version 8.6
#    Oct 18, 2023 04:33:30 PM -03  platform: Windows NT


import inspect
import os
import xlsxwriter

# Image/plot modules
import matplotlib.pyplot as plt
from PIL import Image,ImageTk

# TKinter modules
import tkinter as tk
from tkinter.messagebox import showerror, showwarning, showinfo
from tkinter import filedialog

# from tabulate import tabulate
from prettytable import PrettyTable

# project modules
import gui_main_2
import canvas_manager as canvasmanager
import media
import ScaleWinDialog as swd

import sys
sys.path.append('procedures')
from Jeffries import jeffries_procedure
from Heyns import heyns_procedure
import procedures_support as ps


_debug = True # False to eliminate debug printing from callback functions.

def main(*args):
    '''Main entry point for the application.'''
    
    global gsp_old
    gsp_old = 0
    
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, MainWindow
    _top1 = root
    MainWindow = gui_main_2.Toplevel_MainWindow(_top1)
    
    global image_analyzer
    image_analyzer = media.MEDIA()    # object for Metallographic Image Analysis class
    
    global cmanager
    cmanager = canvasmanager.CanvasManager(MainWindow.MainCanvas)  
    
    root.mainloop()
    
    # h = MainWindow.CanvasHistogram.winfo_height()
    
# def callback_movement(event):
#     """Captura as coordenadas do cursor sobre a tela de canvas"""
    
#     x = (event.x-55)/image_analyzer.image_prop.ratio
#     y = (event.y-55)/image_analyzer.image_prop.ratio
#     str = "x = {:.2f}, y = {:.2f}".format(x,y)    
#     MainWindow.Label_coords.config(text=str)
    
        
def open_segmentation_panel():
    """Open segmentation window settings"""
    global child
    child_root_segmentation = tk.Toplevel(root)
    child = gui_main_2.TopLevel_SegmentationWindow(child_root_segmentation)
    child_root_segmentation.attributes('-topmost',True)
    
    child.edge_detection_var.set("Canny")
    child.meanSTD_var.set("1")
    child.rb_filter.set(1)
    child.drawcnt_var.set(1)
    

def open_procedure_panel():
    """Open the ASTM procedures window"""

    # if not image_analyzer.is_image_segmented():
    #     showwarning("Warning","Procedures can not be applied until grains segmentation has been performed.")
    #     return 
    
    global child_procedure
    child_root_procedure = tk.Toplevel(root)
    child_procedure = gui_main_2.TopLevel_MeasuringProcedure(child_root_procedure)
    child_root_procedure.attributes('-topmost',True)
    
    child_procedure.LineLength.insert(0, "0 um")
    child_procedure.NumLinesHeyns.insert(0,"1 line")
    child_procedure.CircunferenceJeffriesArea.insert(0,"5000 mm^2")
    child_procedure.RB_procedure.set(1)
    
def apply_procedure_button():
    """Apply ASTM procedure choose by user"""
    
    var = int(child_procedure.RB_procedure.get())
    procedures = ["Jeffries", "Heyns"]
    print("Procedure: ", procedures[var-1])
    
    canvas = MainWindow.MainCanvas
    colors = image_analyzer.colors
    width, height = image_analyzer.get_image_dimensions()
    
    
    print("Por aqui passa: 01")
    image_analyzer.image_cv = None
    image_analyzer.image_cv = image_analyzer.image_original.copy()
    print("Por aqui passa: 02")
    
    if procedures[var-1]=="Jeffries":
        radius = image_analyzer.image_prop.Jeffrie_radius()        
        circunference = [radius, ((int(width/2), int(height/2)))]
        
        
        intcpd_area, inside_area, intcpd_contours, inside_contours = jeffries_procedure(circunference, 
                                                                                        image_analyzer.grains_area, 
                                                                                        image_analyzer.grains_contours)
        num_intcp = len(intcpd_contours)
        num_inside = len(inside_contours)
        
        
        if len(intcpd_area)==0:
            showerror("Planimetric Jeffries procedure error", "No intercepted grains found")
        if len(inside_area)==0:
            showerror("Planimetric Jeffries procedure error", "No inside grains found")        
        
        image_analyzer.draw_contours(contours=inside_contours, contour_color=colors.black, area_color = colors.magenta_light)        
        image_analyzer.draw_contours(contours=intcpd_contours, contour_color=colors.black, area_color = colors.green_light)
        cmanager.update(image_analyzer)
        
        # calculate grain size number
        G = ps.get_G_number("Jeffries", num_intcp, N_inside=num_inside)
        print("Grain size number: %f  (Jeffries procedure)" % G)
        
        # draw circunference only after canvas update or it will overlap the circunference       
        ps.draw_circunference(canvas, circunference)   
    elif procedures[var-1] =="Heyns":
        
        # take the image width to lines length
        # line_length = width
        
        # check entry box for length. It is initialized with 0um
        # micrometer -> milimeter
        line_length = float(child_procedure.LineLength.get())
        var_nlines = int(child_procedure.NumLinesHeyns.get())
        
        linelength_px = image_analyzer.image_prop.um_to_px(line_length)
        full_intercpt, half_intercpt = heyns_procedure(image_analyzer.grains_area, 
                                          image_analyzer.grains_contours, 
                                          width, height, linelength_px, num_lines=var_nlines)
        
        num_intcp = len(full_intercpt) + 0.5*len(half_intercpt)
        print("len(full_intercpt) = ",len(full_intercpt))
        print("len(half_intercpt) = ",len(half_intercpt))
        print("num_intcp = ",num_intcp)
        
        image_analyzer.draw_contours(contours=full_intercpt, contour_color=colors.black, area_color = colors.magenta_light)
        image_analyzer.draw_contours(contours=half_intercpt, contour_color=colors.black, area_color = colors.green_light)
        # update canvas
        cmanager.update(image_analyzer)        
        ps.draw_lines(canvas, width, height, linelength_px, nlines=var_nlines)
      
        # calculate grain size number
        G = ps.get_G_number("Heyns", num_intcp, length=0.001*line_length*var_nlines)
        print("Grain size number: %f  (Heyns procedure)" % G)
    else:
        showerror("Error", "Only Jeffries and Heyn procedures are available.")
        
    


def print_message_on_TextBoard(msg):
    MainWindow.TextBox_output.insert('end',msg+'\n', ("centered"))
    MainWindow.TextBox_output.tag_configure("centered", justify='center')


def createPrettyTable():
    """
    Creates a table structure to be displayed as a PrettyTable. 
    It can be exported as well 
    """
    title, header, rows_analysis = image_analyzer.get_report_analysis()            
    rows_imgprop =                 image_analyzer.image_prop.get_report_analysis()            
    rows = rows_analysis + rows_imgprop 
    
    table = PrettyTable()
    table.title = title
    table.field_names = header
    table.add_rows(rows)
    table.align = "l"
    return table


def print_table_on_TextBoard(table):    
    MainWindow.TextBox_output.insert(tk.END, table)
    MainWindow.TextBox_output.insert('end','\n\n')
    
    
def apply_image_filter(the_filter):
    """Applies image filter selected on TopLevel_SegmentationWindow"""
    image_analyzer.set_image_filter(the_filter)
    image_analyzer.apply_filter_smooth_algorithms()
    
    fimg = image_analyzer.get_filtered_image()
    cimg = image_analyzer.set_image_for_canvas(fimg)    
    cmanager.display_image_on_canvas(cimg)


def select_filter():
    """Select image filter from VScale widget and then apply it to image.
    The filter can only be applied to a loaded image, otherwise warn user. """
    
    filter_name = ['None',
                   'Gaussian blur',
                   '2D convolution',
                   'Bilateral Filter',
                   'Median Blurring',
                   'Averaging',
                   'Laplacian']  
    
    i = int(child.rb_filter.get())
    
    print('filter name: ' + filter_name[i-1])
    
    if image_analyzer.is_image_loaded():
        apply_image_filter(filter_name[i-1])
    elif not(filter_name[i-1] == 'None'):
        print_message_on_TextBoard('Warning! Image file not loaded.')  
        

def start_grains_segmentation():
    """Defines if the user wants to detect grain/porous structure or phases through
    the group of radio buttons. The action is performed pressing <detect structure>
    button."""
    
    if not image_analyzer.is_image_loaded():
        msg=[1,"No file has been openned!"]
        CHKMSG(msg)
    else:
    
        # Edge detection Procedure
        edp = child.edge_detection_var.get()
        
        # Control grains size area display
        gsp = int(child.meanSTD_var.get())
    
        
        # Canny
        if edp=="Canny":
            """Performe image segmentation finding grains' constours and updating canvas.
               Returns an error if image was not loaded.
            """
    
            if not image_analyzer.img_loaded:
                showerror('Grains segmentation','Image file has not been opened.')
            else:
                
                msg=image_analyzer.find_grains(gsp)
                CHKMSG(msg)                
                
                #Convert grains areas in pixels to micrometers
                image_analyzer.convert_grains_pixel2micro()
               
                # after analysis, display report on text box                
                table = createPrettyTable()
                print_table_on_TextBoard(table)                
            
                # setup canvas for image display
                setup_canvas()
                
                display_options()
                
                # set loaded image to be displayed on canvas
                cimg = image_analyzer.set_image_for_canvas(image_analyzer.image_cv)
                
                # cimg = image_analyzer.get_image_for_canvas()
                cmanager.display_image_on_canvas(cimg)
                
                image_analyzer.save_analysis_image_files("sample")
                
                plot()
            
                
        else:
            showerror('Error','Phases detection not implemented yet.')       


def display_options():
    """
    Manager how grains should be displayed. Options read from checkboxes
    """
    if child.colorfill_var.get()==1:
        image_analyzer.fill_contours()
    
    if child.drawcnt_var.get()==1:
        image_analyzer.draw_contours()
        
    if child.boundarybox_var.get()==1:
        image_analyzer.draw_bounding_box()
        
    if child.numberedgrains_var.get()==1:
        image_analyzer.numbering_grains()
        
    if child.minmax_var.get()==1:
        image_analyzer.draw_minmax_grains_area()
        
        
def select_measuring_procedure():
    """Defines which of the ASTM procedures to use"""
    var = child.rb_procedure_var.get()
    if var==1:
        print("Jeffries")
    elif var==2:
        print("Heyn")
    elif var==3:
        print("Hilliard")
    elif var==4:
        print("Abram")


def close_application(): 
    msg_box = tk.messagebox.askquestion('Exit Application', 
                                        'Are you sure you want to exit the application?',
                                        icon='warning')
    if msg_box == 'yes':
        root.destroy()

        
def open_image_file():
    
    filetypes = (
        ('Image file', '*.png *.jpg *jpeg'),
        ('HDF5', '*.hdf5'),
        ('All files', '*.*')
    )
    
    filename = filedialog.askopenfilename(
        title='Open a file',
        initialdir='/Users/roger/OneDrive/UFRPE/PESQUISA/Projeto - Analise de imagens metalograficas/Git/gui/UI_metallographic_image_analysis/images',
        filetypes=filetypes)

    if filename == '':        
        showinfo(title='Selected File',  
                 message="No image file opened.")
    else:
        
        # load image file: it just creates a cv2 object
        image_analyzer.load_image(filename)
        
        # setup canvas for image display
        setup_canvas()
        
        # Display directory path and file name on MainWindow
        MainWindow.LabelDirectoryPathName.configure(text=filename)
        
        
def setup_canvas():
    
    if not image_analyzer.is_image_loaded():
        showerror("Error","Image not loaded! ")
    else:
        
        # remove all previous graphics from previous image analysis
        cmanager.cleanup()
        
        # set loaded image to be displayed on canvas
        oimg = image_analyzer.get_image_original()
        
        # set loaded image to be displayed on canvas
        cimg = image_analyzer.set_image_for_canvas(oimg)
        
        # cimg = image_analyzer.get_image_for_canvas()
        cmanager.display_image_on_canvas(cimg)
        
        # set x-y scales on canvas 
        width, height = image_analyzer.get_image_dimensions() 
        cmanager.draw_xy_axis(width, height, image_analyzer.image_prop)
        

def open_data_image_window():
    """It just opens the Data Image Window and start event"""

    if not image_analyzer.is_image_loaded():
        showerror("Error", "Image not loaded!")
    else:
        global child_dataimage, child_root
        child_root = tk.Toplevel(root)
        child_dataimage = gui_main_2.ImageDataWindow(child_root)
        child_root.attributes('-topmost',True)
        
        global scale_win
        scale_win = swd.SWD(root, MainWindow.MainCanvas)
        root.bind("<Motion>", lambda e: scale_win.callback_movement(e))
        root.bind("<Button-1>", lambda e: scale_win.callback_click(e)) 
    
    
def conclude_data_image_collect():
    print("conclude_data_image_collect():")
    """
    Set image parameters (magnification and scale).
    Update image scale rulers (x-y): pixels to micrometers
    Closes window
    """   

    # if child_dataimage.EntryMagnification.get() == "":
    #     showwarning('Warning:','Image magnification unknow.')
    #     return 1
    
    # if child_dataimage.EntryScale.get() == "":
    #     showwarning('Warning:','Scale value unknow.')
    #     return 1
    
    # From scale window, get: 
    # 1. image magnification      (Entry box widget), 
    # 2. scale length             (pixels: from the red ruler plotted over drawing)
    # 3. scale taken from picture (micrometers: Entry box widget)
    M = 100 #float(child_dataimage.EntryMagnification.get())    
    scale_micrometers = 100 #float(child_dataimage.EntryScale.get())
    
    image_analyzer.image_prop.Magnification = M
    image_analyzer.image_prop.scale_micrometers = scale_micrometers
    
    
    info = 'Magnification: ' + str(M) + '\n Scale (um):' + str(scale_micrometers)
    # showinfo("Data image info", info)
    
    scale_pixels = 60 #scale_win.get()    
    info = 'scale_pixels = ' + str(scale_pixels)
    # showinfo("Data image info: ", info)
    
    width, height = image_analyzer.get_image_dimensions()
    image_analyzer.image_prop.convertion_scale_settings(scale_micrometers, 
                                                        scale_pixels, 
                                                        M, 
                                                        width, 
                                                        height)
    
    # apague a marcação da régua usada para capturar a escala da imagem e
    # redesenhe os valores das escalas vertical e horizontal (pixel -> um)
    setup_canvas()

    # close data image window    
    child_root.destroy()
    
       
def plot():  
    """
    Plots on canvas the histogram of grains areas
    """

    x = image_analyzer.grains_area
    
    num_bins = 42
    
    fig, ax = plt.subplots(figsize=(6.9, 4.6))
    
    # the histogram of the data
    n, bins, patches = ax.hist(x, num_bins, density=True)
    
    ax.set_xlabel('Value')
    ax.set_ylabel('Probability density')
    ax.set_title('Histogram of grains areas')   
    plt.savefig("hist.png", bbox_inches='tight')
    
    
    one = ImageTk.PhotoImage(Image.open("hist.png"))
    root.one = one
    MainWindow.CanvasHistogram.create_image(0,0,image=one, anchor=tk.NW)
    
  

def exporttoxlxs():
    """
    Description:
        
        Export the last data analysis to a .xlxs file.
    """
    
    filename = filedialog.asksaveasfilename(initialfile = 'Untitled.xlsx',
                                            defaultextension=".xlsx",
                                            filetypes=[("Excel file","*.xlsx")])
    
    print('filename = ', filename)
    print('filename type = ', type(filename) )
    
    # get data to be written to file
    title, header, data_rows = image_analyzer.get_report_analysis()
    
    # Create a workbook and add a worksheet.
    workbook = xlsxwriter.Workbook(filename)
    worksheet = workbook.add_worksheet()
    
    # Start from the first cell. Rows and columns are zero indexed.
    row = 1
    col = 1
    
    # # print title
    # print('TITLE = ', title)
    worksheet.write(row, col, title)
    
    # # print headers
    row += 2
    worksheet.write(row, col, str(header[0]))
    worksheet.write(row, col+1, str(header[1]))
    
    # Iterate over the data and write it out row by row.
    row += 1
    for r in data_rows:
        worksheet.write(row, col,     r[0])
        worksheet.write(row, col + 1, r[1])
        row += 1
    
    workbook.close()
    
def about():
    showinfo('About MEDIA:',
                    'The Metallographic Digital Image Analyzer:\n\n'
                    'Institution: UFRPE - UACSA\n'
                    'Author: Prof. Rogério Soares da Silva\n'
                    'e-mail: rogerio.soaress@ufrpe.br\n'
                    'Year  : 2023')
    
    
def getLineInfo():
    print("\nInspection")
    print("---------------------------------------------------------------------")
    print("File     : " + os.path.basename(inspect.stack()[1][1])  + 
          "\nLine     : " + str(inspect.stack()[1][2])+
          "\nFunction : " + inspect.stack()[1][3])
    print("---------------------------------------------------------------------\n\n")
    
def CHKMSG(msg):
    if len(msg):
       if msg[0]==1:
           showwarning("Warning",msg[1])
       elif msg[0]==-1:
           showerror("Fatal error",msg[1])
           root.destroy()
    
if __name__ == '__main__':
    gui_main_2.start_up()




